// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package gitprotocolio

import (
	"fmt"
	"io"
)

type protocolV2ResponseState int

const (
	protocolV2ResponseStateBegin protocolV2ResponseState = iota
	protocolV2ResponseStateScanResponse
	protocolV2ResponseStateEnd
)

// ProtocolV2ResponseChunk is a chunk of a protocol v2 response.
type ProtocolV2ResponseChunk struct {
	Response    []byte
	Delimiter   bool
	EndResponse bool
}

// EncodeToPktLine serializes the chunk.
func (c *ProtocolV2ResponseChunk) EncodeToPktLine() []byte {
	if len(c.Response) != 0 {
		return BytesPacket(c.Response).EncodeToPktLine()
	}
	if c.Delimiter {
		return DelimPacket{}.EncodeToPktLine()
	}
	if c.EndResponse {
		return FlushPacket{}.EncodeToPktLine()
	}
	panic("impossible chunk")
}

// ProtocolV2Response provides an interface for reading a protocol v2 response.
type ProtocolV2Response struct {
	scanner *PacketScanner
	state   protocolV2ResponseState
	err     error
	curr    *ProtocolV2ResponseChunk
}

// NewProtocolV2Response returns a new ProtocolV2Response to read from rd.
func NewProtocolV2Response(rd io.Reader) *ProtocolV2Response {
	return &ProtocolV2Response{scanner: NewPacketScanner(rd)}
}

// Err returns the first non-EOF error that was encountered by the
// ProtocolV2Response.
func (r *ProtocolV2Response) Err() error {
	return r.err
}

// Chunk returns the most recent request chunk generated by a call to Scan.
//
// The underlying array of Response may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (r *ProtocolV2Response) Chunk() *ProtocolV2ResponseChunk {
	return r.curr
}

// Scan advances the scanner to the next packet. It returns false when the scan
// stops, either by reaching the end of the input or an error. After scan
// returns false, the Err method will return any error that occurred during
// scanning, except that if it was io.EOF, Err will return nil.
func (r *ProtocolV2Response) Scan() bool {
	if r.err != nil || r.state == protocolV2ResponseStateEnd {
		return false
	}
	if !r.scanner.Scan() {
		r.err = r.scanner.Err()
		if r.err == nil && r.state != protocolV2ResponseStateBegin {
			r.err = SyntaxError("early EOF")
		}
		return false
	}

	switch p := r.scanner.Packet().(type) {
	case FlushPacket:
		r.state = protocolV2ResponseStateBegin
		r.curr = &ProtocolV2ResponseChunk{
			EndResponse: true,
		}
		return true
	case DelimPacket:
		r.state = protocolV2ResponseStateScanResponse
		r.curr = &ProtocolV2ResponseChunk{
			Delimiter: true,
		}
		return true
	case BytesPacket:
		r.state = protocolV2ResponseStateScanResponse
		r.curr = &ProtocolV2ResponseChunk{
			Response: p,
		}
		return true
	default:
		r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", r.scanner.Packet()))
		return false
	}
}
