// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gitprotocolio

import (
	"fmt"
	"io"
	"strings"
)

type protocolV1ReceivePackResponseState int

const (
	protocolV1ReceivePackResponseStateBegin protocolV1ReceivePackResponseState = iota
	protocolV1ReceivePackResponseStateScanResult
	protocolV1ReceivePackResponseStateEnd
)

// ProtocolV1ReceivePackResponseChunk is a chunk of a protocol v1
// git-receive-pack response.
type ProtocolV1ReceivePackResponseChunk struct {
	UnpackStatus         string
	RefUpdateStatus      string
	RefName              string
	RefUpdateFailMessage string
	EndOfResponse        bool
}

// EncodeToPktLine serializes the chunk.
func (c *ProtocolV1ReceivePackResponseChunk) EncodeToPktLine() []byte {
	if c.UnpackStatus != "" {
		return BytesPacket([]byte(fmt.Sprintf("unpack %s\n", c.UnpackStatus))).EncodeToPktLine()
	}
	if c.RefUpdateStatus != "" {
		if c.RefUpdateFailMessage == "" {
			return BytesPacket([]byte(fmt.Sprintf("%s %s\n", c.RefUpdateStatus, c.RefName))).EncodeToPktLine()
		}
		return BytesPacket([]byte(fmt.Sprintf("%s %s %s\n", c.RefUpdateStatus, c.RefName, c.RefUpdateFailMessage))).EncodeToPktLine()
	}
	if c.EndOfResponse {
		return FlushPacket{}.EncodeToPktLine()
	}
	panic("impossible chunk")
}

// ProtocolV1ReceivePackResponse provides an interface for reading a protocol v1
// git-receive-pack response.
type ProtocolV1ReceivePackResponse struct {
	scanner *PacketScanner
	state   protocolV1ReceivePackResponseState
	err     error
	curr    *ProtocolV1ReceivePackResponseChunk
}

// NewProtocolV1ReceivePackResponse returns a new ProtocolV1ReceivePackResponse
// to read from rd.
func NewProtocolV1ReceivePackResponse(rd io.Reader) *ProtocolV1ReceivePackResponse {
	return &ProtocolV1ReceivePackResponse{scanner: NewPacketScanner(rd)}
}

// Err returns the first non-EOF error that was encountered by the
// ProtocolV1ReceivePackResponse.
func (r *ProtocolV1ReceivePackResponse) Err() error {
	return r.err
}

// Chunk returns the most recent response chunk generated by a call to Scan.
func (r *ProtocolV1ReceivePackResponse) Chunk() *ProtocolV1ReceivePackResponseChunk {
	return r.curr
}

// Scan advances the scanner to the next packet. It returns false when the scan
// stops, either by reaching the end of the input or an error. After scan
// returns false, the Err method will return any error that occurred during
// scanning, except that if it was io.EOF, Err will return nil.
func (r *ProtocolV1ReceivePackResponse) Scan() bool {
	if r.err != nil || r.state == protocolV1ReceivePackResponseStateEnd {
		return false
	}
	if !r.scanner.Scan() {
		r.err = r.scanner.Err()
		if r.err == nil && r.state != protocolV1ReceivePackResponseStateBegin {
			r.err = SyntaxError("early EOF")
		}
		return false
	}
	pkt := r.scanner.Packet()
	switch r.state {
	case protocolV1ReceivePackResponseStateBegin:
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		s := strings.TrimSuffix(string(bp), "\n")
		if !strings.HasPrefix(s, "unpack ") {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", s))
			return false
		}
		r.state = protocolV1ReceivePackResponseStateScanResult
		r.curr = &ProtocolV1ReceivePackResponseChunk{
			UnpackStatus: strings.SplitN(s, " ", 2)[1],
		}
		return true
	case protocolV1ReceivePackResponseStateScanResult:
		switch p := pkt.(type) {
		case FlushPacket:
			r.state = protocolV1ReceivePackResponseStateEnd
			r.curr = &ProtocolV1ReceivePackResponseChunk{
				EndOfResponse: true,
			}
			return true
		case BytesPacket:
			s := strings.TrimSuffix(string(p), "\n")
			if strings.HasPrefix(s, "ok ") {
				ss := strings.SplitN(s, " ", 2)
				r.curr = &ProtocolV1ReceivePackResponseChunk{
					RefUpdateStatus: ss[0],
					RefName:         ss[1],
				}
				return true
			}
			if strings.HasPrefix(s, "ng ") {
				ss := strings.SplitN(s, " ", 3)
				if len(ss) != 3 {
					r.err = SyntaxError("cannot split into three: " + s)
					return false
				}
				r.curr = &ProtocolV1ReceivePackResponseChunk{
					RefUpdateStatus:      ss[0],
					RefName:              ss[1],
					RefUpdateFailMessage: ss[2],
				}
				return true
			}
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		default:
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", p))
			return false
		}
	}
	panic("impossible state")
}
