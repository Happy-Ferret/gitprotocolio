// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gitprotocolio

import (
	"fmt"
	"io"
	"strconv"
	"strings"
)

type protocolV1UploadPackRequestState int

const (
	protocolV1UploadPackRequestStateBegin protocolV1UploadPackRequestState = iota
	protocolV1UploadPackRequestStateScanWants
	protocolV1UploadPackRequestStateScanShallows
	protocolV1UploadPackRequestStateScanDepth
	protocolV1UploadPackRequestStateScanFilter
	protocolV1UploadPackRequestStateBeginNegotiationOrDoneOrEnd
	protocolV1UploadPackRequestStateNegotiation
	protocolV1UploadPackRequestStateScanHaves
	protocolV1UploadPackRequestStateEnd
)

// ProtocolV1UploadPackRequestChunk is a chunk of a protocol v1 git-upload-pack
// request.
type ProtocolV1UploadPackRequestChunk struct {
	Capabilities    []string
	WantObjectID    string
	ShallowObjectID string
	DeepenDepth     int
	// Not documented, but seconds from UNIX epoch.
	DeepenSince       uint64
	DeepenNotRef      string
	FilterSpec        string
	HaveObjectID      string
	EndOneRound       bool
	NoMoreNegotiation bool
}

// EncodeToPktLine serializes the chunk.
func (c *ProtocolV1UploadPackRequestChunk) EncodeToPktLine() []byte {
	if len(c.Capabilities) > 0 && c.WantObjectID != "" {
		return BytesPacket([]byte(fmt.Sprintf("want %s %s\n", c.WantObjectID, strings.Join(c.Capabilities, " ")))).EncodeToPktLine()
	}
	if c.WantObjectID != "" {
		return BytesPacket([]byte(fmt.Sprintf("want %s\n", c.WantObjectID))).EncodeToPktLine()
	}
	if c.ShallowObjectID != "" {
		return BytesPacket([]byte(fmt.Sprintf("shallow %s\n", c.ShallowObjectID))).EncodeToPktLine()
	}
	if c.DeepenDepth != 0 {
		return BytesPacket([]byte(fmt.Sprintf("deepen %d\n", c.DeepenDepth))).EncodeToPktLine()
	}
	if c.DeepenSince != 0 {
		return BytesPacket([]byte(fmt.Sprintf("deepen-since %d\n", c.DeepenSince))).EncodeToPktLine()
	}
	if c.DeepenNotRef != "" {
		return BytesPacket([]byte(fmt.Sprintf("deepen-not %s\n", c.DeepenNotRef))).EncodeToPktLine()
	}
	if c.FilterSpec != "" {
		return BytesPacket([]byte(fmt.Sprintf("filter %s\n", c.FilterSpec))).EncodeToPktLine()
	}
	if c.HaveObjectID != "" {
		return BytesPacket([]byte(fmt.Sprintf("have %s\n", c.HaveObjectID))).EncodeToPktLine()
	}
	if c.EndOneRound {
		return FlushPacket{}.EncodeToPktLine()
	}
	if c.NoMoreNegotiation {
		return BytesPacket([]byte("done\n")).EncodeToPktLine()
	}
	panic("impossible chunk")
}

// ProtocolV1UploadPackRequest provides an interface for reading a protocol v1
// git-upload-pack request.
type ProtocolV1UploadPackRequest struct {
	scanner *PacketScanner
	state   protocolV1UploadPackRequestState
	err     error
	curr    *ProtocolV1UploadPackRequestChunk
}

// NewProtocolV1UploadPackRequest returns a new ProtocolV1UploadPackRequest to
// read from rd.
func NewProtocolV1UploadPackRequest(rd io.Reader) *ProtocolV1UploadPackRequest {
	return &ProtocolV1UploadPackRequest{scanner: NewPacketScanner(rd)}
}

// Err returns the first non-EOF error that was encountered by the
// ProtocolV1UploadPackRequest.
func (r *ProtocolV1UploadPackRequest) Err() error {
	return r.err
}

// Chunk returns the most recent chunk generated by a call to Scan.
func (r *ProtocolV1UploadPackRequest) Chunk() *ProtocolV1UploadPackRequestChunk {
	return r.curr
}

// Scan advances the scanner to the next packet. It returns false when the scan
// stops, either by reaching the end of the input or an error. After scan
// returns false, the Err method will return any error that occurred during
// scanning, except that if it was io.EOF, Err will return nil.
func (r *ProtocolV1UploadPackRequest) Scan() bool {
	if r.err != nil || r.state == protocolV1UploadPackRequestStateEnd {
		return false
	}
	if !r.scanner.Scan() {
		r.err = r.scanner.Err()
		if r.err == nil && r.state != protocolV1UploadPackRequestStateBeginNegotiationOrDoneOrEnd {
			r.err = SyntaxError("early EOF")
		}
		return false
	}
	pkt := r.scanner.Packet()

	if r.state == protocolV1UploadPackRequestStateBegin {
		bp, ok := pkt.(BytesPacket)
		if !ok {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		ss := strings.SplitN(string(bp), " ", 3)
		if len(ss) < 2 {
			r.err = SyntaxError("cannot split wants: " + string(bp))
			return false
		}
		caps := []string{}
		if len(ss) == 3 {
			if capStr := strings.TrimSuffix(ss[2], "\n"); capStr != "" {
				// This is to avoid strings.Split("", " ") => []string{""}.
				caps = strings.Split(capStr, " ")
			}
		}
		if ss[0] != "want" {
			r.err = SyntaxError("the first packet is not want: " + string(bp))
		}
		r.state = protocolV1UploadPackRequestStateScanWants
		r.curr = &ProtocolV1UploadPackRequestChunk{
			Capabilities: caps,
			WantObjectID: ss[1],
		}
		return true
	}

	if _, ok := pkt.(FlushPacket); ok {
		r.state = protocolV1UploadPackRequestStateBeginNegotiationOrDoneOrEnd
		r.curr = &ProtocolV1UploadPackRequestChunk{
			EndOneRound: true,
		}
		return true
	}

	bp, ok := pkt.(BytesPacket)
	if !ok {
		r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
		return false
	}
	s := strings.TrimSuffix(string(bp), "\n")

	if s == "done" {
		if r.state == protocolV1UploadPackRequestStateNegotiation || r.state == protocolV1UploadPackRequestStateBeginNegotiationOrDoneOrEnd {
			r.state = protocolV1UploadPackRequestStateEnd
			r.curr = &ProtocolV1UploadPackRequestChunk{
				NoMoreNegotiation: true,
			}
			return true
		}
		r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
		return false
	}

	ss := strings.SplitN(s, " ", 2)
	if len(ss) != 2 {
		r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
		return false
	}

	switch r.state {
	case protocolV1UploadPackRequestStateScanWants:
		if ss[0] == "want" {
			r.curr = &ProtocolV1UploadPackRequestChunk{
				WantObjectID: ss[1],
			}
			return true
		}
		fallthrough
	case protocolV1UploadPackRequestStateScanShallows:
		if ss[0] == "shallow" {
			r.state = protocolV1UploadPackRequestStateScanShallows
			r.curr = &ProtocolV1UploadPackRequestChunk{
				ShallowObjectID: ss[1],
			}
			return true
		}
		fallthrough
	case protocolV1UploadPackRequestStateScanDepth:
		if ss[0] == "deepen" {
			depth, err := strconv.ParseInt(ss[1], 10, strconv.IntSize)
			if err != nil {
				r.err = SyntaxError("cannot parse depth")
				return false
			}
			r.state = protocolV1UploadPackRequestStateScanFilter
			r.curr = &ProtocolV1UploadPackRequestChunk{
				DeepenDepth: int(depth),
			}
			return true
		}
		if ss[0] == "deepen-since" {
			since, err := strconv.ParseUint(ss[1], 10, 64)
			if err != nil {
				r.err = SyntaxError("cannot parse depth")
				return false
			}
			r.state = protocolV1UploadPackRequestStateScanFilter
			r.curr = &ProtocolV1UploadPackRequestChunk{
				DeepenSince: since,
			}
			return true
		}
		if ss[0] == "deepen-not" {
			r.state = protocolV1UploadPackRequestStateScanFilter
			r.curr = &ProtocolV1UploadPackRequestChunk{
				DeepenNotRef: ss[1],
			}
			return true
		}
		fallthrough
	case protocolV1UploadPackRequestStateScanFilter:
		if ss[0] != "filter" {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		r.state = protocolV1UploadPackRequestStateNegotiation
		r.curr = &ProtocolV1UploadPackRequestChunk{
			FilterSpec: ss[1],
		}
		return true
	case protocolV1UploadPackRequestStateNegotiation, protocolV1UploadPackRequestStateBeginNegotiationOrDoneOrEnd:
		if ss[0] != "have" {
			r.err = SyntaxError(fmt.Sprintf("unexpected packet: %#v", pkt))
			return false
		}
		r.state = protocolV1UploadPackRequestStateNegotiation
		r.curr = &ProtocolV1UploadPackRequestChunk{
			HaveObjectID: ss[1],
		}
		return true
	}
	panic("impossible state")
}
